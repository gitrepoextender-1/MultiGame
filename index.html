<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebase Game Hub</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for games and mobile */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .game-card {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .game-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        /* Tic-Tac-Toe Styles */
        .tttoe-cell {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: 800;
            cursor: pointer;
            border: 2px solid #cbd5e1;
            transition: background-color 0.1s;
        }
        .tttoe-cell:hover:not(.occupied) {
            background-color: #eff6ff;
        }
        /* Memory Game Tile Styles */
        .memory-tile {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            transition: transform 0.3s ease, background-color 0.3s ease;
            transform-style: preserve-3d;
            background-color: #3b82f6;
            cursor: pointer;
        }
        .memory-tile.flipped {
            background-color: #10b981;
            transform: rotateY(180deg);
        }
        .memory-tile.matched {
            background-color: #f59e0b;
            cursor: default;
        }
        .memory-tile-inner {
            transform: rotateY(180deg); /* Text is visible only when flipped */
        }
        /* Gold Miner Styles */
        #miner-btn {
            background: linear-gradient(145deg, #FFC107, #FF9800);
            box-shadow: 0 6px #E65100;
            transition: all 0.1s;
        }
        #miner-btn:active {
            box-shadow: 0 2px #E65100;
            transform: translateY(4px);
        }
        /* RPS Styles */
        .rps-choice {
            padding: 1rem;
            border-radius: 12px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }
        .rps-choice:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .rps-choice.selected {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <header class="mb-8 flex justify-between items-center flex-wrap">
        <h1 id="header-title" class="text-3xl font-extrabold text-blue-600 cursor-pointer" onclick="navigate('home')">
            🎮 Game Hub
        </h1>
        <div id="auth-info" class="flex items-center space-x-3 mt-4 md:mt-0">
            <!-- Auth status will be rendered here -->
        </div>
    </header>

    <main id="app-container" class="max-w-6xl mx-auto"></main>

    <!-- Modal for general messages/errors -->
    <div id="message-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full">
            <h3 id="modal-title" class="text-xl font-bold mb-3 text-gray-800"></h3>
            <p id="modal-body" class="text-gray-600 mb-6"></p>
            <button onclick="hideModal()" class="w-full bg-blue-600 text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition">Close</button>
        </div>
    </div>


    <script type="module">
        // --- FIREBASE IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, addDoc, updateDoc, deleteDoc, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // setLogLevel('Debug'); // Uncomment for Firestore debug logs

        // --- HARDCODED FIREBASE CONFIG ---
        // NOTE: The user is expected to replace this with their own Vercel/GitHub Pages Firebase project config.
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyC85wey_dOt8uiOyjxOdzwmdLPxK0qlav4",
            authDomain: "multigame-a032d.firebaseapp.com",
            projectId: "multigame-a032d",
            storageBucket: "multigame-a032d.firebasestorage.app",
            messagingSenderId: "51842272357",
            appId: "1:51842272357:web:c8951b57e3a729f8db4a8c",
            measurementId: "G-GJPMKV1XX0"
        };
        
        // --- FIREBASE INITIALIZATION ---
        const app = initializeApp(FIREBASE_CONFIG);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // --- APPLICATION STATE ---
        let currentUser = null;
        let userId = null; 
        let isAuthReady = false; 
        const UNSUBSCRIBE_HANDLERS = {}; 

        // --- UTILITY FUNCTIONS (Global access needed for inline HTML events) ---

        /** Shows a custom modal message instead of alert() */
        window.showModal = function(title, message) { // EXPOSED TO GLOBAL SCOPE
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-body').textContent = message;
            document.getElementById('message-modal').classList.remove('hidden');
        }

        /** Hides the custom modal */
        window.hideModal = function() { // EXPOSED TO GLOBAL SCOPE
            document.getElementById('message-modal').classList.add('hidden');
        }

        /** Cleans up all active Firestore listeners before navigation. */
        function cleanupListeners() {
            Object.keys(UNSUBSCRIBE_HANDLERS).forEach(key => {
                if (typeof UNSUBSCRIBE_HANDLERS[key] === 'function') {
                    UNSUBSCRIBE_HANDLERS[key]();
                }
                delete UNSUBSCRIBE_HANDLERS[key];
            });
        }

        /** Helper for creating Firestore paths (simplified for external environments) */
        const getCollectionPath = (collectionName, isPublic = true, specificUserId = null) => {
            if (!userId) {
                showModal("Service Not Ready", "Authentication is still initializing. Please wait a moment.");
                return null;
            }
            if (isPublic) {
                return collectionName; // Returns just 'tictactoe_games' for root-level access
            }
            const currentUserId = specificUserId || userId;
            return `users/${currentUserId}/${collectionName}`;
        };

        // --- AUTHENTICATION LOGIC ---

        /** Renders the user status and controls in the header. */
        function renderAuthInfo() {
            const container = document.getElementById('auth-info');
            container.innerHTML = '';
            
            if (currentUser) {
                const isAnon = currentUser.isAnonymous;
                const emailDisplay = isAnon ? 'Guest User' : (currentUser.email || `User ID: ${currentUser.uid.substring(0, 8)}...`);
                
                const userElement = document.createElement('span');
                userElement.className = 'text-sm font-medium text-gray-700 truncate max-w-[100px] md:max-w-none';
                userElement.textContent = isAnon ? 'Guest' : emailDisplay;
                userElement.title = `Full User ID: ${currentUser.uid}`;

                const logoutButton = document.createElement('button');
                logoutButton.className = 'bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-3 rounded-lg transition text-sm shadow';
                logoutButton.textContent = 'Logout';
                logoutButton.onclick = async () => {
                    await signOut(auth);
                    navigate('home');
                };

                const loginButton = document.createElement('button');
                loginButton.className = 'bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition text-sm shadow';
                loginButton.textContent = isAnon ? 'Login / Signup' : 'Account';
                loginButton.onclick = () => navigate('auth');
                
                if (isAnon) {
                    container.append(userElement, loginButton);
                } else {
                    container.append(userElement, logoutButton);
                }

            } else if (userId) {
                 // Fallback if anonymous sign-in failed, but we have a temp ID
                 const userElement = document.createElement('span');
                 userElement.className = 'text-sm font-medium text-gray-700';
                 userElement.textContent = 'Error State Guest';
                 const loginButton = document.createElement('button');
                 loginButton.className = 'bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition text-sm shadow';
                 loginButton.textContent = 'Login / Signup';
                 loginButton.onclick = () => navigate('auth');
                 container.appendChild(loginButton);
            }
        }

        /** FIX: Initializes Firebase Authentication, waiting for a persistent session first. */
        async function initializeAuth() {
            // Use onAuthStateChanged as the single source of truth for the session state
            onAuthStateChanged(auth, async (user) => {
                let finalUser = user;
                
                // If no user (no persistent session found), force anonymous sign-in
                if (!finalUser) {
                    try {
                        const anonUserCred = await signInAnonymously(auth);
                        finalUser = anonUserCred.user;
                    } catch (e) {
                        console.error("Anonymous sign-in failed:", e);
                        // If anonymous sign-in fails, we use a temporary client-side ID
                        userId = 'temp-' + (Math.random().toString(36).substring(2, 9)); 
                        currentUser = null;
                        isAuthReady = true;
                        renderAuthInfo();
                        handleNavigation();
                        return;
                    }
                }
                
                // Set final state and mark as ready
                currentUser = finalUser;
                userId = finalUser.uid;
                isAuthReady = true;

                renderAuthInfo();
                handleNavigation(); 
            });
        }


        // --- ROUTING AND NAVIGATION (Global access needed for inline HTML events) ---

        /** Navigates the application via hash change. */
        window.navigate = (path, params = {}) => { // EXPOSED TO GLOBAL SCOPE
            let hash = `#/${path}`;
            if (params.id) {
                hash += `?id=${params.id}`;
            }
            window.location.hash = hash;
        };

        /** Handles hash change events to load the correct component. */
        function handleNavigation() {
            cleanupListeners(); // IMPORTANT: Clear listeners before navigating away

            const hash = window.location.hash.substring(1) || '/home';
            const [path, queryString] = hash.split('?');
            const [gameName] = path.substring(1).split('/');

            const params = {};
            if (queryString) {
                new URLSearchParams(queryString).forEach((value, key) => {
                    params[key] = value;
                });
            }

            const container = document.getElementById('app-container');
            container.innerHTML = '';

            // Wait for auth to be ready before rendering any game/view
            if (!isAuthReady) {
                container.innerHTML = '<div class="text-center p-8 text-gray-500">Initializing services...</div>';
                return;
            }

            switch (gameName) {
                case 'home':
                    renderDashboard(container);
                    break;
                case 'auth':
                    renderAuthForm(container);
                    break;
                case 'tictactoe-lobby':
                    renderTicTacToeLobby(container);
                    break;
                case 'tictactoe':
                    if (params.id) {
                        renderTicTacToeGame(container, params.id);
                    } else {
                        navigate('tictactoe-lobby');
                    }
                    break;
                case 'memory':
                    renderMemoryGame(container);
                    break;
                case 'goldminer':
                    renderGoldMiner(container);
                    break;
                case 'rps-lobby':
                    renderRPSLobby(container);
                    break;
                case 'rps':
                     if (params.id) {
                        renderRPSGame(container, params.id);
                    } else {
                        navigate('rps-lobby');
                    }
                    break;
                default:
                    renderDashboard(container);
            }
        }

        window.addEventListener('hashchange', handleNavigation);

        // --- DASHBOARD/HOME VIEW ---

        function renderDashboard(container) {
            // Note: userId is guaranteed to be non-null and isAuthReady is true here.
            
            // Handle case where anonymous sign-in failed (very rare)
            const isErrorState = !currentUser && userId.startsWith('temp-');

            let warningMessage = '';
            if (isErrorState) {
                warningMessage = '<p class="text-red-500 font-bold mt-2">Authentication Error: Multiplayer and save features are unavailable.</p>';
            } else if (currentUser && currentUser.isAnonymous) {
                warningMessage = '<p class="text-yellow-700 font-bold mt-2">You are signed in as a Guest. Log in to save scores and play multiplayer.</p>';
            }

            container.innerHTML = `
                <div class="text-center mb-8">
                    <h2 class="text-4xl font-extrabold text-gray-900 mb-2">Welcome to the Game Hub</h2>
                    <p class="text-gray-600">Choose a game below to get started. Your User ID: <span class="font-mono text-xs">${userId}</span></p>
                    ${warningMessage}
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                    <!-- Game 1: Tic-Tac-Toe -->
                    <div id="card-tictactoe" class="game-card bg-white p-6 rounded-xl shadow-lg border border-blue-100" onclick="navigate('tictactoe-lobby')">
                        <div class="text-5xl mb-4 text-blue-600">
                            <span class="inline-block transform rotate-6">✖️</span>
                            <span class="inline-block transform -rotate-6">⭕</span>
                        </div>
                        <h3 class="text-xl font-bold mb-2">Tic-Tac-Toe (PVP)</h3>
                        <p class="text-gray-500 text-sm">Real-time multiplayer challenge.</p>
                        <span class="mt-4 inline-block text-sm font-semibold text-blue-500">Play →</span>
                    </div>

                    <!-- Game 2: Memory Match -->
                    <div id="card-memory" class="game-card bg-white p-6 rounded-xl shadow-lg border border-green-100" onclick="navigate('memory')">
                        <div class="text-5xl mb-4 text-green-600">🧠</div>
                        <h3 class="text-xl font-bold mb-2">Memory Match (Solo)</h3>
                        <p class="text-gray-500 text-sm">Test your memory. Saves lowest move count.</p>
                        <span class="mt-4 inline-block text-sm font-semibold text-green-500">Play →</span>
                    </div>

                    <!-- Game 3: Gold Miner (NEW) -->
                    <div id="card-miner" class="game-card bg-white p-6 rounded-xl shadow-lg border border-amber-100" onclick="navigate('goldminer')">
                        <div class="text-5xl mb-4 text-amber-600">⛏️</div>
                        <h3 class="text-xl font-bold mb-2">Gold Miner (Clicker)</h3>
                        <p class="text-gray-500 text-sm">Persistent idle/clicker game. Saves gold count.</p>
                        <span class="mt-4 inline-block text-sm font-semibold text-amber-500">Play →</span>
                    </div>
                    
                    <!-- Game 4: Rock, Paper, Scissors (NEW) -->
                    <div id="card-rps" class="game-card bg-white p-6 rounded-xl shadow-lg border border-purple-100" onclick="navigate('rps-lobby')">
                        <div class="text-5xl mb-4 text-purple-600">✂️🪨📄</div>
                        <h3 class="text-xl font-bold mb-2">RPS (PVP)</h3>
                        <p class="text-gray-500 text-sm">Real-time Rock-Paper-Scissors. Commit & Reveal.</p>
                        <span class="mt-4 inline-block text-sm font-semibold text-purple-500">Play →</span>
                    </div>
                </div>
            `;
        }

        // --- AUTH FORM VIEW (Relying on the fixed initializeAuth for persistence) ---

        function renderAuthForm(container) {
            if (currentUser && !currentUser.isAnonymous) {
                container.innerHTML = '<div class="text-center p-8 bg-green-100 rounded-xl">You are already logged in! Redirecting...</div>';
                setTimeout(() => navigate('home'), 1500);
                return;
            }

            container.innerHTML = `
                <div class="max-w-md mx-auto bg-white p-8 rounded-xl shadow-xl border border-gray-100">
                    <h2 class="text-3xl font-bold text-center mb-6 text-gray-800" id="auth-heading">Login</h2>
                    <form id="auth-form" class="space-y-4">
                        <div>
                            <label for="auth-email" class="block text-sm font-medium text-gray-700">Email</label>
                            <input type="email" id="auth-email" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <div>
                            <label for="auth-password" class="block text-sm font-medium text-gray-700">Password</label>
                            <input type="password" id="auth-password" required minlength="6" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <button type="submit" id="auth-submit-btn" class="w-full bg-blue-600 text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition shadow-md">Login</button>
                    </form>
                    <div class="text-center mt-4">
                        <button id="toggle-auth-btn" class="text-sm text-blue-600 hover:text-blue-700 transition">
                            Don't have an account? Switch to Signup
                        </button>
                    </div>
                </div>
            `;

            const form = document.getElementById('auth-form');
            const heading = document.getElementById('auth-heading');
            const submitBtn = document.getElementById('auth-submit-btn');
            const toggleBtn = document.getElementById('toggle-auth-btn');

            let isLogin = true;

            const toggleMode = () => {
                isLogin = !isLogin;
                heading.textContent = isLogin ? 'Login' : 'Signup';
                submitBtn.textContent = isLogin ? 'Login' : 'Create Account';
                toggleBtn.textContent = isLogin ? "Don't have an account? Switch to Signup" : "Already have an account? Switch to Login";
            };

            toggleBtn.onclick = toggleMode;

            form.onsubmit = async (e) => {
                e.preventDefault();
                const email = document.getElementById('auth-email').value;
                const password = document.getElementById('auth-password').value;

                try {
                    if (isLogin) {
                        await signInWithEmailAndPassword(auth, email, password);
                        showModal("Success", "Logged in successfully! Redirecting to home.");
                    } else {
                        await createUserWithEmailAndPassword(auth, email, password);
                        showModal("Success", "Account created and logged in! Redirecting to home.");
                    }
                    setTimeout(() => navigate('home'), 1000);
                } catch (error) {
                    const errorMessage = error.message.replace('Firebase: Error (auth/', '').replace(/\)./, '');
                    showModal("Authentication Failed", errorMessage);
                    console.error("Auth error:", error);
                }
            };
        }

        // ----------------------------------------------------
        // --- GAME 1: TIC-TAC-TOE (Multiplayer, Public Data) ---
        // ----------------------------------------------------

        const TTTOE_COLLECTION = 'tictactoe_games';

        function renderTicTacToeLobby(container) {
            if (currentUser.isAnonymous) {
                container.innerHTML = `
                    <div class="text-center p-8 bg-yellow-100 rounded-xl shadow-lg border-yellow-300 border-l-4">
                        <h3 class="text-xl font-bold text-yellow-800 mb-4">Multiplayer requires sign-in</h3>
                        <p class="text-gray-600 mb-4">Please <a href="#/auth" class="text-blue-600 font-semibold hover:underline">log in or sign up</a> with Email/Password to create or join a real-time multiplayer game.</p>
                        <button onclick="navigate('home')" class="bg-gray-400 text-white font-semibold py-2 px-4 rounded-lg hover:bg-gray-500 transition">Go Back</button>
                    </div>
                `;
                return;
            }

            container.innerHTML = `
                <div class="text-center mb-8">
                    <h2 class="text-3xl font-bold text-gray-900">Tic-Tac-Toe Lobby</h2>
                    <p class="text-gray-600">Create a new game or join an open challenge.</p>
                </div>
                <div class="max-w-xl mx-auto space-y-4">
                    <button id="create-game-btn" class="w-full bg-green-600 text-white font-semibold py-3 rounded-lg hover:bg-green-700 transition shadow-lg">
                        ➕ Create New Game
                    </button>
                    <div class="bg-white p-4 rounded-xl shadow-md">
                        <h3 class="text-xl font-semibold mb-3">Open Games</h3>
                        <div id="open-games-list" class="space-y-2">
                            <p class="text-gray-500 text-center">Loading open games...</p>
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('create-game-btn').onclick = createTicTacToeGame;
            listenForOpenGames();
        }

        async function createTicTacToeGame() {
            const path = getCollectionPath(TTTOE_COLLECTION, true);
            if (!path) return;

            const playerName = currentUser.email || `User ${userId.substring(0, 4)}`;

            const newGame = {
                board: Array(9).fill(null),
                status: 'waiting', // 'waiting', 'playing', 'win', 'draw'
                playerX: userId,
                playerO: null,
                currentTurn: 'X',
                creatorId: userId,
                createdAt: new Date().toISOString(),
                winner: null,
                playerNames: { 'X': playerName }
            };

            try {
                const docRef = await addDoc(collection(db, path), newGame);
                navigate('tictactoe', { id: docRef.id });
            } catch (error) {
                showModal("Game Creation Failed", "Could not create game session. Check console for details.");
                console.error("Error creating game:", error);
            }
        }

        function listenForOpenGames() {
            const path = getCollectionPath(TTTOE_COLLECTION, true);
            if (!path) return;

            const q = query(collection(db, path), where("status", "==", "waiting"));
            const listContainer = document.getElementById('open-games-list');

            UNSUBSCRIBE_HANDLERS['tttoe-lobby'] = onSnapshot(q, (snapshot) => {
                listContainer.innerHTML = '';
                let hasGames = false;

                snapshot.forEach(doc => {
                    const game = doc.data();
                    // Only show games not created by the current user
                    if (game.playerX !== userId) { 
                        hasGames = true;
                        const gameElement = document.createElement('div');
                        gameElement.className = 'flex justify-between items-center bg-gray-50 p-3 rounded-lg border';
                        gameElement.innerHTML = `
                            <span class="font-medium text-gray-700">Host: ${game.playerNames['X']}</span>
                            <!-- FIX: Button now calls global window.joinTicTacToeGame -->
                            <button onclick="window.joinTicTacToeGame('${doc.id}')" class="bg-blue-500 text-white text-sm font-semibold py-1 px-3 rounded-md hover:bg-blue-600 transition">
                                Join (as O)
                            </button>
                        `;
                        listContainer.appendChild(gameElement);
                    }
                });
                
                if (!hasGames) {
                    listContainer.innerHTML = '<p class="text-gray-500 text-center p-4">No open games found. Be the first to create one!</p>';
                }
            });
        }

        // FIX: EXPOSE TO WINDOW SCOPE for onclick handlers to find it.
        window.joinTicTacToeGame = async function(gameId) {
            const path = getCollectionPath(TTTOE_COLLECTION, true);
            if (!path) return;

            const gameRef = doc(db, path, gameId);
            const playerName = currentUser.email || `User ${userId.substring(0, 4)}`;

            try {
                await updateDoc(gameRef, {
                    playerO: userId,
                    status: 'playing',
                    [`playerNames.O`]: playerName
                });
                navigate('tictactoe', { id: gameId });
            } catch (error) {
                const errorMsg = error.message || error.toString();
                showModal("Joining Failed", `Could not join this Tic-Tac-Toe game. Error: ${errorMsg}. Check console for details.`);
                console.error("Error joining TicTacToe game:", error);
            }
        }

        function renderTicTacToeGame(container, gameId) {
            container.innerHTML = `
                <div class="max-w-md mx-auto p-6 bg-white rounded-xl shadow-2xl border border-gray-100 text-center">
                    <h2 class="text-3xl font-extrabold mb-4 text-blue-600">Tic-Tac-Toe</h2>
                    <div id="game-status" class="text-xl font-semibold mb-4 text-gray-800">Loading Game...</div>
                    <div id="game-info" class="text-sm text-gray-500 mb-6"></div>
                    <div id="tttoe-board" class="grid grid-cols-3 gap-1 mx-auto max-w-xs border-4 border-gray-300 p-1 rounded-lg">
                        <!-- Cells will be generated here -->
                    </div>
                    <div id="action-buttons" class="mt-8 space-y-3">
                        <button onclick="navigate('tictactoe-lobby')" class="w-full bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-gray-600 transition shadow">
                            ← Back to Lobby
                        </button>
                        <button id="delete-game-btn" class="w-full bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition shadow hidden">
                            Delete Game
                        </button>
                    </div>
                </div>
            `;
            listenForTicTacToeUpdates(gameId);
        }

        function listenForTicTacToeUpdates(gameId) {
            const path = getCollectionPath(TTTOE_COLLECTION, true);
            if (!path) return;

            const gameRef = doc(db, path, gameId);
            const boardContainer = document.getElementById('tttoe-board');
            const statusElement = document.getElementById('game-status');
            const infoElement = document.getElementById('game-info');
            const deleteBtn = document.getElementById('delete-game-btn');

            UNSUBSCRIBE_HANDLERS['tttoe-game'] = onSnapshot(gameRef, (docSnap) => {
                if (!docSnap.exists()) {
                    showModal("Game Ended", "This game session was deleted by the host.");
                    navigate('tictactoe-lobby');
                    return;
                }

                const game = docSnap.data();
                const playerSymbol = game.playerX === userId ? 'X' : (game.playerO === userId ? 'O' : null);
                
                // Show delete button only to host and if game is finished/abandoned
                deleteBtn.classList.add('hidden');
                if (game.playerX === userId && (game.status === 'win' || game.status === 'draw' || game.playerO === null)) {
                    deleteBtn.classList.remove('hidden');
                    deleteBtn.onclick = () => {
                        deleteDoc(gameRef).catch(e => {
                            showModal("Error", "Could not delete game.");
                            console.error("Error deleting:", e);
                        });
                    };
                }


                // Update status and info
                let statusText = '';
                let isGameActive = true;
                const playerXName = game.playerNames['X'] || 'Player X';
                const playerOName = game.playerNames['O'] || 'Player O';
                let infoText = `X: ${playerXName} | O: ${playerOName}`;

                if (game.status === 'waiting') {
                    statusText = `Waiting for Player O...`;
                    isGameActive = false;
                } else if (game.status === 'playing') {
                    const myTurn = game.currentTurn === playerSymbol;
                    statusText = myTurn ? `Your Turn (${playerSymbol})` : `Opponent's Turn (${game.currentTurn})`;
                } else if (game.status === 'win') {
                    const winnerName = game.playerNames[game.winner] || game.winner;
                    statusText = `Winner: ${game.winner === playerSymbol ? 'You' : winnerName}!`;
                    isGameActive = false;
                } else if (game.status === 'draw') {
                    statusText = 'Game Draw!';
                    isGameActive = false;
                }
                
                statusElement.textContent = statusText;
                infoElement.innerHTML = infoText;

                // Render board
                boardContainer.innerHTML = '';
                game.board.forEach((cell, index) => {
                    const cellEl = document.createElement('div');
                    cellEl.className = `tttoe-cell ${cell ? 'occupied' : ''} ${cell === 'X' ? 'text-blue-500' : (cell === 'O' ? 'text-red-500' : 'text-gray-900')}`;
                    cellEl.textContent = cell || '';
                    // Pass the whole docSnap data to the move handler
                    cellEl.onclick = () => makeTicTacToeMove(gameRef, game, index, playerSymbol, isGameActive); 
                    boardContainer.appendChild(cellEl);
                });
            }, (error) => {
                console.error("TicTacToe Stream Error:", error);
                showModal("Connection Error", "Lost connection to the game. Try refreshing.");
            });
        }

        function checkWinner(board, player) {
            const combos = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];
            return combos.some(combo => combo.every(index => board[index] === player));
        }

        async function makeTicTacToeMove(gameRef, game, index, playerSymbol, isGameActive) {
            if (!isGameActive || !playerSymbol) {
                if (!playerSymbol) showModal("Spectator Mode", "You are not a player in this game.");
                return;
            }

            if (game.board[index] !== null) return;
            if (game.currentTurn !== playerSymbol) {
                showModal("Not Your Turn", `It is ${game.currentTurn}'s turn.`);
                return;
            }

            const newBoard = [...game.board];
            newBoard[index] = playerSymbol;

            let newStatus = 'playing';
            let newWinner = null;
            
            if (checkWinner(newBoard, playerSymbol)) {
                newStatus = 'win';
                newWinner = playerSymbol;
            } else if (newBoard.every(cell => cell !== null)) {
                newStatus = 'draw';
            }

            try {
                await updateDoc(gameRef, {
                    board: newBoard,
                    currentTurn: newStatus === 'playing' ? (playerSymbol === 'X' ? 'O' : 'X') : null,
                    status: newStatus,
                    winner: newWinner,
                });
            } catch (error) {
                showModal("Move Failed", "Could not register move. Check console.");
                console.error("Error updating game state:", error);
            }
        }


        // ----------------------------------------------------
        // --- GAME 2: MEMORY MATCH (Single Player, Private Data) ---
        // ----------------------------------------------------

        const MEMORY_SCORE_COLLECTION = 'memory_scores';
        let memoryGame = {
            tiles: [],
            moves: 0,
            flipped: [],
            matched: [],
            gameActive: false,
            highScore: null,
            highScoreDocId: null,
        };
        let isSavingScore = false; 

        function setupMemoryGame() {
            const symbols = ['🍎', '🍌', '🥝', '🍉', '🍍', '🥭', '🍇', '🍓'];
            let tiles = [...symbols, ...symbols]
                .sort(() => 0.5 - Math.random()) 
                .map((symbol, id) => ({ id, symbol, isFlipped: false, isMatched: false }));

            memoryGame = {
                ...memoryGame, // Keep high score properties
                tiles,
                moves: 0,
                flipped: [],
                matched: [],
                gameActive: true,
            };
        }

        function renderMemoryGame(container) {
            const isGuest = currentUser && currentUser.isAnonymous;

             if (isGuest) {
                container.innerHTML = `<div class="text-center p-8 bg-yellow-100 rounded-xl shadow-lg border-yellow-300 border-l-4">
                        <h3 class="text-xl font-bold text-yellow-800 mb-4">Login for Persistent Scores</h3>
                        <p class="text-gray-600 mb-4">You can play, but your high score will not be saved unless you <a href="#/auth" class="text-blue-600 font-semibold hover:underline">log in or sign up</a>.</p>
                        <button onclick="navigate('home')" class="bg-gray-400 text-white font-semibold py-2 px-4 rounded-lg hover:bg-gray-500 transition">Go Back</button>
                    </div><div class="mt-8" id="memory-game-content"></div>`;
                container = document.getElementById('memory-game-content');
            }
            
            container.innerHTML += `
                <div class="max-w-3xl mx-auto p-6 bg-white rounded-xl shadow-2xl border border-green-100 text-center">
                    <h2 class="text-3xl font-extrabold mb-4 text-green-600">Memory Match</h2>
                    <div class="flex justify-between items-center mb-6 text-gray-700 font-semibold text-lg flex-wrap">
                        <span id="memory-moves">Moves: 0</span>
                        <span id="memory-score" class="text-green-700">High Score: ...</span>
                    </div>

                    <div id="memory-board" class="grid grid-cols-4 sm:grid-cols-6 gap-3 mx-auto max-w-lg">
                        <p class="col-span-4 sm:col-span-6 text-gray-500 pt-4">Click Start to begin!</p>
                    </div>

                    <div id="game-message" class="mt-6 text-xl font-bold text-red-500"></div>

                    <button id="memory-start-btn" class="mt-8 w-full md:w-1/2 bg-green-600 text-white font-semibold py-3 rounded-lg hover:bg-green-700 transition shadow-lg">
                        Start New Game
                    </button>
                </div>
            `;
            document.getElementById('memory-start-btn').onclick = () => {
                setupMemoryGame();
                renderMemoryBoard();
                document.getElementById('memory-start-btn').textContent = "Restart Game";
                document.getElementById('game-message').textContent = "";
            };

            listenForHighScore();
        }

        function renderMemoryBoard() {
            const boardContainer = document.getElementById('memory-board');
            if (!boardContainer) return;

            boardContainer.innerHTML = '';
            document.getElementById('memory-moves').textContent = `Moves: ${memoryGame.moves}`;
            
            const scoreEl = document.getElementById('memory-score');
            if (scoreEl) {
                const isGuest = currentUser && currentUser.isAnonymous;
                scoreEl.textContent = `High Score: ${memoryGame.highScore !== null ? memoryGame.highScore + ' Moves' : (isGuest ? 'N/A (Guest)' : 'N/A')}`;
            }

            if (memoryGame.tiles.length === 0) {
                 boardContainer.innerHTML = '<p class="col-span-4 sm:col-span-6 text-gray-500 pt-4">Click Start to begin!</p>';
                 return;
            }

            memoryGame.tiles.forEach(tile => {
                const tileEl = document.createElement('div');
                tileEl.className = `memory-tile ${tile.isFlipped ? 'flipped' : ''} ${tile.isMatched ? 'matched' : ''}`;
                tileEl.style.cursor = memoryGame.gameActive && !tile.isFlipped ? 'pointer' : 'default';

                tileEl.innerHTML = `<div class="memory-tile-inner">${tile.symbol}</div>`;
                
                if (!tile.isFlipped && !tile.isMatched) {
                    tileEl.innerHTML = `<div class="memory-tile-inner transform-none text-3xl">❓</div>`;
                }

                tileEl.onclick = () => handleTileClick(tile.id);
                boardContainer.appendChild(tileEl);
            });
        }

        function handleTileClick(id) {
            if (!memoryGame.gameActive) {
                document.getElementById('game-message').textContent = "Click 'Start New Game' to play!";
                return;
            }

            const tileIndex = memoryGame.tiles.findIndex(t => t.id === id);
            const tile = memoryGame.tiles[tileIndex];

            if (tile.isFlipped || tile.isMatched || memoryGame.flipped.length === 2) return;

            tile.isFlipped = true;
            memoryGame.flipped.push(tile);
            renderMemoryBoard();

            if (memoryGame.flipped.length === 2) {
                memoryGame.moves++;
                const [tile1, tile2] = memoryGame.flipped;

                if (tile1.symbol === tile2.symbol) {
                    // Match found
                    tile1.isMatched = true;
                    tile2.isMatched = true;
                    memoryGame.matched.push(tile1, tile2);
                    memoryGame.flipped = [];
                    
                    if (memoryGame.matched.length === memoryGame.tiles.length) {
                        endMemoryGame();
                    }
                    renderMemoryBoard();

                } else {
                    // No match, flip back after a delay
                    setTimeout(() => {
                        tile1.isFlipped = false;
                        tile2.isFlipped = false;
                        memoryGame.flipped = [];
                        renderMemoryBoard();
                    }, 800);
                }
            }
        }

        function endMemoryGame() {
            memoryGame.gameActive = false;
            document.getElementById('game-message').textContent = `🎉 You Win in ${memoryGame.moves} Moves!`;
            
            const isGuest = currentUser && currentUser.isAnonymous;

            if (currentUser && !isGuest) {
                checkAndSaveHighScore(memoryGame.moves);
            } else {
                showModal("Game Finished", `You completed the game in ${memoryGame.moves} moves. Log in to save your high score!`);
            }
        }

        async function listenForHighScore() {
            const isGuest = currentUser && currentUser.isAnonymous;
            if (isGuest) return;
            const path = getCollectionPath(MEMORY_SCORE_COLLECTION, false);
            if (!path) return;

            const q = query(collection(db, path)); 
            
            UNSUBSCRIBE_HANDLERS['memory-score'] = onSnapshot(q, (snapshot) => {
                 if (!snapshot.empty) {
                    const docSnap = snapshot.docs[0];
                    memoryGame.highScore = docSnap.data().highScore;
                    memoryGame.highScoreDocId = docSnap.id;
                } else {
                    memoryGame.highScore = null;
                    memoryGame.highScoreDocId = null;
                }
                renderMemoryBoard(); // Update the displayed score
            }, (error) => {
                console.error("Memory Score Stream Error:", error);
            });
        }

        async function checkAndSaveHighScore(moves) {
            if (isSavingScore) return;
            isSavingScore = true;
            
            const path = getCollectionPath(MEMORY_SCORE_COLLECTION, false);
            if (!path) {
                isSavingScore = false;
                return;
            }

            const currentScore = memoryGame.highScore;
            const isNewHighScore = currentScore === null || moves < currentScore;

            if (isNewHighScore) {
                const scoreData = {
                    userId: userId,
                    highScore: moves,
                    lastUpdated: new Date().toISOString()
                };

                try {
                    const collectionRef = collection(db, path);
                    if (memoryGame.highScoreDocId) {
                        // Update existing document
                        const docRef = doc(db, path, memoryGame.highScoreDocId);
                        await updateDoc(docRef, scoreData);
                    } else {
                        // Create new document (we expect only one per user in the private collection)
                        await addDoc(collectionRef, scoreData);
                    }

                    document.getElementById('game-message').textContent = `⭐ New High Score: ${moves} Moves! ⭐`;
                } catch (error) {
                    showModal("Score Save Failed", "Could not save high score to Firebase. Check if security rules allow writes.");
                    console.error("Error saving score:", error);
                }
            } 
            isSavingScore = false;
        }


        // ----------------------------------------------------
        // --- GAME 3: GOLD MINER (Single Player, Persistent Private Data) ---
        // ----------------------------------------------------

        const MINER_COLLECTION = 'miner_data';
        let minerState = {
            gold: 0,
            clickPower: 1,
            goldPerSecond: 0,
            upgrades: {
                pickaxe: 0, // Click Power upgrade
                worker: 0  // GPS upgrade
            },
            saveDocId: null
        };
        let lastUpdateTime = Date.now();
        let gameLoopInterval = null;

        const UPGRADE_COSTS = {
            pickaxe: level => Math.round(10 * Math.pow(1.5, level)),
            worker: level => Math.round(20 * Math.pow(1.7, level))
        };
        const UPGRADE_BONUS = {
            pickaxe: 1, // +1 click power
            worker: 0.5 // +0.5 gold per second
        };

        function calculateGPS() {
            return minerState.upgrades.worker * UPGRADE_BONUS.worker;
        }
        function calculateClickPower() {
            return 1 + (minerState.upgrades.pickaxe * UPGRADE_BONUS.pickaxe);
        }

        function renderGoldMiner(container) {
            const isGuest = currentUser && currentUser.isAnonymous;

             if (isGuest) {
                container.innerHTML = `<div class="text-center p-8 bg-yellow-100 rounded-xl shadow-lg border-yellow-300 border-l-4">
                        <h3 class="text-xl font-bold text-yellow-800 mb-4">Login for Persistent Save</h3>
                        <p class="text-gray-600 mb-4">You can play, but your progress will not be saved unless you <a href="#/auth" class="text-blue-600 font-semibold hover:underline">log in or sign up</a>.</p>
                        <button onclick="navigate('home')" class="bg-gray-400 text-white font-semibold py-2 px-4 rounded-lg hover:bg-gray-500 transition">Go Back</button>
                    </div><div class="mt-8" id="miner-game-content"></div>`;
                container = document.getElementById('miner-game-content');
            }
            
            container.innerHTML += `
                <div class="max-w-2xl mx-auto p-6 bg-white rounded-xl shadow-2xl border border-amber-100 text-center">
                    <h2 class="text-3xl font-extrabold mb-4 text-amber-600">Gold Miner Clicker</h2>
                    <p class="text-gray-500 mb-6">Mine gold and buy upgrades for more gold per second (GPS).</p>
                    
                    <div class="flex justify-around items-center bg-amber-50 p-4 rounded-lg mb-6 border border-amber-200">
                        <div class="text-center">
                            <div id="gold-display" class="text-4xl font-extrabold text-gray-800">0 Gold</div>
                            <span class="text-sm text-gray-600">Total Gold</span>
                        </div>
                        <div class="text-center">
                            <div id="gps-display" class="text-2xl font-bold text-amber-700">0.0 GPS</div>
                            <span class="text-sm text-gray-600">Gold per Second</span>
                        </div>
                    </div>
                    
                    <button id="miner-btn" class="text-white text-3xl font-bold py-6 px-12 rounded-xl transition shadow-lg w-full mb-8" onclick="mineGold()">
                        ⛏️ Click to Mine (+1)
                    </button>
                    
                    <h3 class="text-2xl font-bold mb-4 text-gray-800">Upgrades</h3>
                    <div id="upgrades-container" class="space-y-3">
                        <!-- Upgrade buttons render here -->
                    </div>
                </div>
            `;
            
            listenForMinerData();
            startGameLoop();
        }
        
        function startGameLoop() {
            if (gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameLoop, 1000 / 10); // Run 10 times per second for smooth FPS
        }
        
        function gameLoop() {
            const now = Date.now();
            const elapsedSeconds = (now - lastUpdateTime) / 1000;
            lastUpdateTime = now;
            
            const isGuest = currentUser && currentUser.isAnonymous;

            if (calculateGPS() > 0) {
                const goldIncrease = calculateGPS() * elapsedSeconds;
                minerState.gold += goldIncrease;
            }
            
            renderMinerUI();
            
            // Save state every 5 seconds (only for non-anonymous users)
            if (now - lastSaveTime > 5000 && !isGuest) {
                saveMinerData();
                lastSaveTime = now;
            }
        }
        let lastSaveTime = Date.now();


        function renderMinerUI() {
            // Update displayed values
            minerState.clickPower = calculateClickPower();
            minerState.goldPerSecond = calculateGPS();

            const gold = Math.floor(minerState.gold);
            document.getElementById('gold-display').textContent = `${gold.toLocaleString()} Gold`;
            document.getElementById('gps-display').textContent = `${minerState.goldPerSecond.toFixed(1)} GPS`;
            document.getElementById('miner-btn').innerHTML = `⛏️ Click to Mine (+${minerState.clickPower})`;
            
            const upgradesContainer = document.getElementById('upgrades-container');
            if (!upgradesContainer) return;
            upgradesContainer.innerHTML = `
                <!-- Pickaxe Upgrade -->
                <button onclick="buyUpgrade('pickaxe')" class="flex justify-between items-center w-full p-3 rounded-lg shadow transition bg-white hover:bg-gray-100 border border-gray-200 disabled:opacity-50" ${gold < UPGRADE_COSTS.pickaxe(minerState.upgrades.pickaxe) ? 'disabled' : ''}>
                    <span class="text-left">
                        <span class="font-bold text-gray-800">Better Pickaxe (Lvl ${minerState.upgrades.pickaxe})</span><br>
                        <span class="text-sm text-gray-600">Click Power: +${UPGRADE_BONUS.pickaxe}</span>
                    </span>
                    <span class="font-bold text-amber-700">${UPGRADE_COSTS.pickaxe(minerState.upgrades.pickaxe).toLocaleString()} Gold</span>
                </button>
                
                <!-- Worker Upgrade -->
                <button onclick="buyUpgrade('worker')" class="flex justify-between items-center w-full p-3 rounded-lg shadow transition bg-white hover:bg-gray-100 border border-gray-200 disabled:opacity-50" ${gold < UPGRADE_COSTS.worker(minerState.upgrades.worker) ? 'disabled' : ''}>
                    <span class="text-left">
                        <span class="font-bold text-gray-800">Hire Worker (Lvl ${minerState.upgrades.worker})</span><br>
                        <span class="text-sm text-gray-600">GPS: +${UPGRADE_BONUS.worker}</span>
                    </span>
                    <span class="font-bold text-amber-700">${UPGRADE_COSTS.worker(minerState.upgrades.worker).toLocaleString()} Gold</span>
                </button>
            `;
        }
        
        function mineGold() {
            minerState.gold += minerState.clickPower;
            renderMinerUI();
        }

        function buyUpgrade(type) {
            const currentLevel = minerState.upgrades[type];
            const cost = UPGRADE_COSTS[type](currentLevel);
            const isGuest = currentUser && currentUser.isAnonymous;
            
            if (minerState.gold >= cost) {
                minerState.gold -= cost;
                minerState.upgrades[type]++;
                renderMinerUI();
                if (!isGuest) {
                     saveMinerData(); // Immediate save on purchase
                }
            } else {
                showModal("Cannot Afford", `You need ${cost.toLocaleString()} Gold to buy this upgrade.`);
            }
        }

        async function listenForMinerData() {
            const isGuest = currentUser && currentUser.isAnonymous;
            if (isGuest) {
                minerState = { ...minerState, gold: 0, clickPower: 1, goldPerSecond: 0, upgrades: { pickaxe: 0, worker: 0 } };
                renderMinerUI();
                return;
            }
            
            const path = getCollectionPath(MINER_COLLECTION, false);
            if (!path) return;

            const q = query(collection(db, path));
            
            UNSUBSCRIBE_HANDLERS['miner-data'] = onSnapshot(q, (snapshot) => {
                 if (!snapshot.empty) {
                    const docSnap = snapshot.docs[0];
                    const data = docSnap.data();
                    
                    // Restore state, handling potential new fields gracefully
                    minerState.gold = data.gold || 0;
                    minerState.upgrades = data.upgrades || { pickaxe: 0, worker: 0 };
                    minerState.saveDocId = docSnap.id;
                    
                    // Compensate for offline time
                    if (data.lastUpdated) {
                        const timeOffline = (Date.now() - new Date(data.lastUpdated).getTime()) / 1000;
                        const gps = calculateGPS(); // Calculate GPS based on loaded upgrades
                        if (timeOffline > 0 && gps > 0) {
                             const idleGold = timeOffline * gps;
                             minerState.gold += idleGold;
                             showModal("Welcome Back, Miner!", `You earned ${Math.floor(idleGold).toLocaleString()} gold while you were away!`);
                        }
                    }
                }
                lastUpdateTime = Date.now();
                renderMinerUI(); // Initial render after loading data
            }, (error) => {
                console.error("Miner Data Stream Error:", error);
            });
        }

        async function saveMinerData() {
            const isGuest = currentUser && currentUser.isAnonymous;
            if (isGuest) return;
            const path = getCollectionPath(MINER_COLLECTION, false);
            if (!path) return;

            const dataToSave = {
                userId: userId,
                gold: minerState.gold, // Save the float value
                upgrades: minerState.upgrades,
                lastUpdated: new Date().toISOString()
            };

            try {
                const collectionRef = collection(db, path);
                if (minerState.saveDocId) {
                    const docRef = doc(db, path, minerState.saveDocId);
                    await updateDoc(docRef, dataToSave);
                } else {
                    const newDocRef = await addDoc(collectionRef, dataToSave);
                    minerState.saveDocId = newDocRef.id;
                }
            } catch (error) {
                console.error("Error saving miner data:", error);
            }
        }


        // ----------------------------------------------------
        // --- GAME 4: ROCK, PAPER, SCISSORS (Multiplayer, Public Data) ---
        // ----------------------------------------------------

        const RPS_COLLECTION = 'rps_games';
        const RPS_CHOICES = {
            'rock': { icon: '🪨', color: 'bg-red-500' },
            'paper': { icon: '📄', color: 'bg-green-500' },
            'scissors': { icon: '✂️', color: 'bg-blue-500' }
        };
        const RPS_WIN_CONDITIONS = {
            'rock': 'scissors',
            'paper': 'rock',
            'scissors': 'paper'
        };

        function renderRPSLobby(container) {
            if (currentUser.isAnonymous) {
                container.innerHTML = `
                    <div class="text-center p-8 bg-yellow-100 rounded-xl shadow-lg border-yellow-300 border-l-4">
                        <h3 class="text-xl font-bold text-yellow-800 mb-4">Multiplayer requires sign-in</h3>
                        <p class="text-gray-600 mb-4">Please <a href="#/auth" class="text-blue-600 font-semibold hover:underline">log in or sign up</a> with Email/Password to play real-time RPS.</p>
                        <button onclick="navigate('home')" class="bg-gray-400 text-white font-semibold py-2 px-4 rounded-lg hover:bg-gray-500 transition">Go Back</button>
                    </div>
                `;
                return;
            }

            container.innerHTML = `
                <div class="text-center mb-8">
                    <h2 class="text-3xl font-bold text-gray-900">RPS Lobby (Commit & Reveal)</h2>
                    <p class="text-gray-600">Create a game or find a challenger.</p>
                </div>
                <div class="max-w-xl mx-auto space-y-4">
                    <button id="create-rps-btn" class="w-full bg-purple-600 text-white font-semibold py-3 rounded-lg hover:bg-purple-700 transition shadow-lg">
                        ➕ Create New RPS Game
                    </button>
                    <div class="bg-white p-4 rounded-xl shadow-md">
                        <h3 class="text-xl font-semibold mb-3">Open Challenges</h3>
                        <div id="open-rps-list" class="space-y-2">
                            <p class="text-gray-500 text-center">Loading open games...</p>
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('create-rps-btn').onclick = createRPSGame;
            listenForOpenRPSGames();
        }

        async function createRPSGame() {
            const path = getCollectionPath(RPS_COLLECTION, true);
            if (!path) return;
            const playerName = currentUser.email || `User ${userId.substring(0, 4)}`;

            const newGame = {
                status: 'waiting', // 'waiting', 'playing', 'reveal', 'done'
                player1Id: userId,
                player2Id: null,
                player1Name: playerName,
                player2Name: null,
                player1Commit: null, // Hashed choice before reveal
                player2Commit: null,
                player1Choice: null, // Revealed choice
                player2Choice: null,
                winner: null,
                round: 1,
                createdAt: new Date().toISOString(),
            };

            try {
                const docRef = await addDoc(collection(db, path), newGame);
                navigate('rps', { id: docRef.id });
            } catch (error) {
                showModal("Game Creation Failed", "Could not create game session. Check console for details.");
                console.error("Error creating RPS game:", error);
            }
        }
        
        function listenForOpenRPSGames() {
            const path = getCollectionPath(RPS_COLLECTION, true);
            if (!path) return;

            const q = query(collection(db, path), where("status", "==", "waiting"));
            const listContainer = document.getElementById('open-rps-list');

            UNSUBSCRIBE_HANDLERS['rps-lobby'] = onSnapshot(q, (snapshot) => {
                listContainer.innerHTML = '';
                let hasGames = false;

                snapshot.forEach(doc => {
                    const game = doc.data();
                    if (game.player1Id !== userId) { 
                        hasGames = true;
                        const gameElement = document.createElement('div');
                        gameElement.className = 'flex justify-between items-center bg-gray-50 p-3 rounded-lg border';
                        gameElement.innerHTML = `
                            <span class="font-medium text-gray-700">Host: ${game.player1Name}</span>
                            <!-- FIX: Button now calls global window.joinRPSGame -->
                            <button onclick="window.joinRPSGame('${doc.id}')" class="bg-blue-500 text-white text-sm font-semibold py-1 px-3 rounded-md hover:bg-blue-600 transition">
                                Join
                            </button>
                        `;
                        listContainer.appendChild(gameElement);
                    }
                });
                
                if (!hasGames) {
                    listContainer.innerHTML = '<p class="text-gray-500 text-center p-4">No open games found. Be the first to create one!</p>';
                }
            });
        }

        // FIX: EXPOSE TO WINDOW SCOPE for onclick handlers to find it.
        window.joinRPSGame = async function(gameId) {
            const path = getCollectionPath(RPS_COLLECTION, true);
            if (!path) return;

            const gameRef = doc(db, path, gameId);
            const playerName = currentUser.email || `User ${userId.substring(0, 4)}`;

            try {
                await updateDoc(gameRef, {
                    player2Id: userId,
                    player2Name: playerName,
                    status: 'playing',
                });
                navigate('rps', { id: gameId });
            } catch (error) {
                const errorMsg = error.message || error.toString();
                showModal("Joining Failed", `Could not join this RPS game. Error: ${errorMsg}. Check console for details.`);
                console.error("Error joining RPS game:", error);
            }
        }

        function renderRPSGame(container, gameId) {
             container.innerHTML = `
                <div class="max-w-xl mx-auto p-6 bg-white rounded-xl shadow-2xl border border-purple-100 text-center">
                    <h2 class="text-3xl font-extrabold mb-4 text-purple-600">Rock, Paper, Scissors</h2>
                    <div id="rps-status" class="text-xl font-semibold mb-4 text-gray-800">Loading Game...</div>
                    <div id="rps-info" class="text-sm text-gray-500 mb-6"></div>
                    
                    <!-- Player choices display -->
                    <div class="flex justify-around items-center mb-6">
                        <div class="text-center">
                            <span class="text-lg font-bold text-gray-700" id="p1-name">...</span>
                            <div class="text-6xl p-4 bg-gray-100 rounded-lg mt-2" id="p1-choice-display">?</div>
                        </div>
                        <span class="text-4xl font-extrabold text-purple-600">VS</span>
                        <div class="text-center">
                            <span class="text-lg font-bold text-gray-700" id="p2-name">...</span>
                            <div class="text-6xl p-4 bg-gray-100 rounded-lg mt-2" id="p2-choice-display">?</div>
                        </div>
                    </div>
                    
                    <div id="rps-action-area" class="mt-8">
                        <!-- Action buttons/choices render here -->
                    </div>

                    <button onclick="navigate('rps-lobby')" class="mt-8 bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-gray-600 transition shadow">
                        ← Back to Lobby
                    </button>
                </div>
            `;
            listenForRPSUpdates(gameId);
        }
        
        async function sha256(str) {
            const buffer = new TextEncoder("utf-8").encode(str);
            const hash = await crypto.subtle.digest("SHA-256", buffer);
            const hashArray = Array.from(new Uint8Array(hash));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }

        function listenForRPSUpdates(gameId) {
            const path = getCollectionPath(RPS_COLLECTION, true);
            if (!path) return;

            const gameRef = doc(db, path, gameId);
            const statusEl = document.getElementById('rps-status');
            const infoEl = document.getElementById('rps-info');
            const actionArea = document.getElementById('rps-action-area');
            const p1NameEl = document.getElementById('p1-name');
            const p2NameEl = document.getElementById('p2-name');
            const p1Display = document.getElementById('p1-choice-display');
            const p2Display = document.getElementById('p2-choice-display');

            UNSUBSCRIBE_HANDLERS['rps-game'] = onSnapshot(gameRef, (docSnap) => {
                if (!docSnap.exists()) {
                    showModal("Game Ended", "This game session was deleted.");
                    navigate('rps-lobby');
                    return;
                }
                const game = docSnap.data();
                const isP1 = game.player1Id === userId;
                const playerCommit = isP1 ? game.player1Commit : game.player2Commit;
                const opponentCommit = isP1 ? game.player2Commit : game.player1Commit;
                const playerChoice = isP1 ? game.player1Choice : game.player2Choice;
                const opponentChoice = isP1 ? game.player2Choice : game.player1Choice;
                
                p1NameEl.textContent = game.player1Name;
                p2NameEl.textContent = game.player2Name || 'Challenger';
                infoEl.textContent = `Round: ${game.round} | ID: ${gameId}`;
                
                p1Display.textContent = playerChoice ? RPS_CHOICES[playerChoice].icon : (game.player1Commit ? '🔒' : '?');
                p2Display.textContent = opponentChoice ? RPS_CHOICES[opponentChoice].icon : (game.player2Commit ? '🔒' : '?');
                
                p1Display.className = `text-6xl p-4 rounded-lg mt-2 ${playerChoice ? RPS_CHOICES[playerChoice].color : 'bg-gray-100'}`;
                p2Display.className = `text-6xl p-4 rounded-lg mt-2 ${opponentChoice ? RPS_CHOICES[opponentChoice].color : 'bg-gray-100'}`;
                
                // State Machine
                if (game.status === 'waiting') {
                    statusEl.textContent = 'Waiting for second player...';
                    actionArea.innerHTML = '';
                } else if (game.status === 'playing') {
                    if (playerCommit) {
                        statusEl.textContent = 'Choice committed. Waiting for opponent...';
                        actionArea.innerHTML = `<button onclick="window.revealRPSChoice('${gameId}', ${isP1})" class="w-full bg-orange-500 text-white font-semibold py-3 rounded-lg hover:bg-orange-600 transition shadow-md" ${opponentCommit ? '' : 'disabled'}>
                            ${opponentCommit ? 'Click to REVEAL (Opponent ready!)' : 'Waiting for opponent to commit...'}
                        </button>`;
                    } else {
                        statusEl.textContent = 'Choose your move:';
                        renderRPSChoices(gameId, isP1, actionArea);
                    }
                } else if (game.status === 'reveal') {
                    if (playerChoice) {
                        statusEl.textContent = `Waiting for opponent to reveal...`;
                        actionArea.innerHTML = '';
                    } else {
                        statusEl.textContent = 'REVEAL your choice!';
                        actionArea.innerHTML = `<button onclick="window.revealRPSChoice('${gameId}', ${isP1})" class="w-full bg-orange-500 text-white font-semibold py-3 rounded-lg hover:bg-orange-600 transition shadow-md">
                            Click to REVEAL
                        </button>`;
                    }
                } else if (game.status === 'done') {
                    let resultText = '';
                    if (game.winner === 'draw') {
                        resultText = 'Draw!';
                    } else if (game.winner === userId) {
                        resultText = 'You Win the Round!';
                    } else {
                        resultText = `${game.winner === game.player1Id ? game.player1Name : game.player2Name} Wins!`;
                    }
                    statusEl.textContent = resultText;
                    actionArea.innerHTML = `<button onclick="window.resetRPSGame('${gameId}')" class="w-full bg-green-600 text-white font-semibold py-3 rounded-lg hover:bg-green-700 transition shadow-md">
                        Start Next Round
                    </button>`;
                }
            });
        }
        
        function renderRPSChoices(gameId, isP1, container) {
            container.innerHTML = `
                <div class="flex justify-around space-x-2">
                    ${Object.keys(RPS_CHOICES).map(choice => `
                        <button onclick="window.commitRPSChoice('${gameId}', '${choice}', ${isP1})" class="rps-choice bg-white shadow-md hover:shadow-lg">
                            <div class="text-5xl">${RPS_CHOICES[choice].icon}</div>
                            <span class="text-sm font-semibold capitalize">${choice}</span>
                        </button>
                    `).join('')}
                </div>
            `;
        }

        // FIX: EXPOSE TO WINDOW SCOPE for onclick handlers to find it.
        window.commitRPSChoice = async function(gameId, choice, isP1) {
            const path = getCollectionPath(RPS_COLLECTION, true);
            if (!path) return;
            const gameRef = doc(db, path, gameId);
            
            const salt = Math.random().toString(36).substring(2, 15);
            const commitHash = await sha256(choice + salt);
            
            const fieldCommit = isP1 ? 'player1Commit' : 'player2Commit';
            
            try {
                // Save the unhashed choice and salt securely in local storage
                localStorage.setItem(`rps_choice_${gameId}_${userId}`, choice);
                localStorage.setItem(`rps_salt_${gameId}_${userId}`, salt);

                await updateDoc(gameRef, {
                    [fieldCommit]: commitHash,
                    [isP1 ? 'player1Choice' : 'player2Choice']: null, // Clear previous choice
                });
            } catch(e) {
                showModal("Commit Failed", "Could not commit choice. Try again.");
                console.error("RPS Commit Error:", e);
            }
        }
        
        // FIX: EXPOSE TO WINDOW SCOPE for onclick handlers to find it.
        window.revealRPSChoice = async function(gameId, isP1) {
            const path = getCollectionPath(RPS_COLLECTION, true);
            if (!path) return;
            const gameRef = doc(db, path, gameId);
            
            // Retrieve the stored choice
            const storedChoice = localStorage.getItem(`rps_choice_${gameId}_${userId}`);

            if (!storedChoice) {
                showModal("Error", "Could not find your committed choice. You may need to commit again.");
                return;
            }

            const fieldChoice = isP1 ? 'player1Choice' : 'player2Choice';
            
            const updateData = {
                [fieldChoice]: storedChoice,
                status: 'reveal'
            };
            
            try {
                await updateDoc(gameRef, updateData);
                
                // After reveal, check if opponent has also revealed to determine winner
                const currentGameState = (await getDoc(gameRef)).data();
                
                if (currentGameState.player1Choice && currentGameState.player2Choice) {
                    determineRPSWinner(gameRef, currentGameState);
                }
                
            } catch(e) {
                showModal("Reveal Failed", "Could not reveal choice. Try again.");
                console.error("RPS Reveal Error:", e);
            }
        }
        
        function determineRPSWinner(gameRef, game) {
            const p1c = game.player1Choice;
            const p2c = game.player2Choice;
            let winnerId = 'draw';
            
            if (p1c === p2c) {
                winnerId = 'draw';
            } else if (RPS_WIN_CONDITIONS[p1c] === p2c) {
                winnerId = game.player1Id; // P1 Wins
            } else {
                winnerId = game.player2Id; // P2 Wins
            }
            
            updateDoc(gameRef, {
                winner: winnerId,
                status: 'done'
            }).catch(e => console.error("Error setting winner:", e));
        }

        // FIX: EXPOSE TO WINDOW SCOPE for onclick handlers to find it.
        window.resetRPSGame = async function(gameId) {
            const path = getCollectionPath(RPS_COLLECTION, true);
            if (!path) return;
            const gameRef = doc(db, path, gameId);
            
            try {
                await updateDoc(gameRef, {
                    status: 'playing',
                    player1Commit: null,
                    player2Commit: null,
                    player1Choice: null,
                    player2Choice: null,
                    winner: null,
                    round: (await getDoc(gameRef)).data().round + 1,
                });
                // Clear local storage for this game and user
                localStorage.removeItem(`rps_choice_${gameId}_${userId}`);
                localStorage.removeItem(`rps_salt_${gameId}_${userId}`);
            } catch(e) {
                showModal("Reset Failed", "Could not reset game. Try refreshing.");
                console.error("RPS Reset Error:", e);
            }
        }


        // --- APPLICATION STARTUP ---

        window.onload = () => {
            initializeAuth(); 
        };

    </script>
</body>
</html>

